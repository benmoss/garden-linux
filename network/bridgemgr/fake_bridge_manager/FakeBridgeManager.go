// This file was generated by counterfeiter
package fake_bridge_manager

import (
	"net"
	"sync"

	"github.com/cloudfoundry-incubator/garden-linux/network/bridgemgr"
)

type FakeBridgeManager struct {
	ReserveStub        func(subnet *net.IPNet, containerId string) (string, error)
	reserveMutex       sync.RWMutex
	reserveArgsForCall []struct {
		subnet      *net.IPNet
		containerId string
	}
	reserveReturns struct {
		result1 string
		result2 error
	}
	RereserveStub        func(bridgeName string, subnet *net.IPNet, containerId string) error
	rereserveMutex       sync.RWMutex
	rereserveArgsForCall []struct {
		bridgeName  string
		subnet      *net.IPNet
		containerId string
	}
	rereserveReturns struct {
		result1 error
	}
	ReleaseStub        func(bridgeName string, containerId string) error
	releaseMutex       sync.RWMutex
	releaseArgsForCall []struct {
		bridgeName  string
		containerId string
	}
	releaseReturns struct {
		result1 error
	}
	PruneStub        func() error
	pruneMutex       sync.RWMutex
	pruneArgsForCall []struct{}
	pruneReturns struct {
		result1 error
	}
}

func (fake *FakeBridgeManager) Reserve(subnet *net.IPNet, containerId string) (string, error) {
	fake.reserveMutex.Lock()
	fake.reserveArgsForCall = append(fake.reserveArgsForCall, struct {
		subnet      *net.IPNet
		containerId string
	}{subnet, containerId})
	fake.reserveMutex.Unlock()
	if fake.ReserveStub != nil {
		return fake.ReserveStub(subnet, containerId)
	} else {
		return fake.reserveReturns.result1, fake.reserveReturns.result2
	}
}

func (fake *FakeBridgeManager) ReserveCallCount() int {
	fake.reserveMutex.RLock()
	defer fake.reserveMutex.RUnlock()
	return len(fake.reserveArgsForCall)
}

func (fake *FakeBridgeManager) ReserveArgsForCall(i int) (*net.IPNet, string) {
	fake.reserveMutex.RLock()
	defer fake.reserveMutex.RUnlock()
	return fake.reserveArgsForCall[i].subnet, fake.reserveArgsForCall[i].containerId
}

func (fake *FakeBridgeManager) ReserveReturns(result1 string, result2 error) {
	fake.ReserveStub = nil
	fake.reserveReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeBridgeManager) Rereserve(bridgeName string, subnet *net.IPNet, containerId string) error {
	fake.rereserveMutex.Lock()
	fake.rereserveArgsForCall = append(fake.rereserveArgsForCall, struct {
		bridgeName  string
		subnet      *net.IPNet
		containerId string
	}{bridgeName, subnet, containerId})
	fake.rereserveMutex.Unlock()
	if fake.RereserveStub != nil {
		return fake.RereserveStub(bridgeName, subnet, containerId)
	} else {
		return fake.rereserveReturns.result1
	}
}

func (fake *FakeBridgeManager) RereserveCallCount() int {
	fake.rereserveMutex.RLock()
	defer fake.rereserveMutex.RUnlock()
	return len(fake.rereserveArgsForCall)
}

func (fake *FakeBridgeManager) RereserveArgsForCall(i int) (string, *net.IPNet, string) {
	fake.rereserveMutex.RLock()
	defer fake.rereserveMutex.RUnlock()
	return fake.rereserveArgsForCall[i].bridgeName, fake.rereserveArgsForCall[i].subnet, fake.rereserveArgsForCall[i].containerId
}

func (fake *FakeBridgeManager) RereserveReturns(result1 error) {
	fake.RereserveStub = nil
	fake.rereserveReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBridgeManager) Release(bridgeName string, containerId string) error {
	fake.releaseMutex.Lock()
	fake.releaseArgsForCall = append(fake.releaseArgsForCall, struct {
		bridgeName  string
		containerId string
	}{bridgeName, containerId})
	fake.releaseMutex.Unlock()
	if fake.ReleaseStub != nil {
		return fake.ReleaseStub(bridgeName, containerId)
	} else {
		return fake.releaseReturns.result1
	}
}

func (fake *FakeBridgeManager) ReleaseCallCount() int {
	fake.releaseMutex.RLock()
	defer fake.releaseMutex.RUnlock()
	return len(fake.releaseArgsForCall)
}

func (fake *FakeBridgeManager) ReleaseArgsForCall(i int) (string, string) {
	fake.releaseMutex.RLock()
	defer fake.releaseMutex.RUnlock()
	return fake.releaseArgsForCall[i].bridgeName, fake.releaseArgsForCall[i].containerId
}

func (fake *FakeBridgeManager) ReleaseReturns(result1 error) {
	fake.ReleaseStub = nil
	fake.releaseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBridgeManager) Prune() error {
	fake.pruneMutex.Lock()
	fake.pruneArgsForCall = append(fake.pruneArgsForCall, struct{}{})
	fake.pruneMutex.Unlock()
	if fake.PruneStub != nil {
		return fake.PruneStub()
	} else {
		return fake.pruneReturns.result1
	}
}

func (fake *FakeBridgeManager) PruneCallCount() int {
	fake.pruneMutex.RLock()
	defer fake.pruneMutex.RUnlock()
	return len(fake.pruneArgsForCall)
}

func (fake *FakeBridgeManager) PruneReturns(result1 error) {
	fake.PruneStub = nil
	fake.pruneReturns = struct {
		result1 error
	}{result1}
}

var _ bridgemgr.BridgeManager = new(FakeBridgeManager)
